#pragma once
#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>
#include <mutex>
#include <condition_variable>
struct TestData {
    int counter = 0;
    std::string justMakingSure = "Not working!";
};
							/**
							 * The ThreadManager handles latency hiding, by controlling both the kernel management and disk writing threads
 							 * and the exchange of information between them.
							 * The implementation is based on the C++11 threading API (https://en.cppreference.com/w/cpp/thread)
							 */
class ThreadManager {
public:
    ThreadManager() = default;   						/** Creates and starts kernel manager and disk write threads. */
    void create();								/** Gracefully shuts down kernel manager and disk write threads. */
    void teardown();								/** Mainly for testing, blocks until both threads quit. */
    void await();
private:
    std::thread diskWriteThread;
    std::thread kernelManagerThread;
    std::atomic<bool> running { false }; 					// true if teardown() has not been called
    std::mutex condMutex; 							// mutex for all condition variables
    std::condition_variable dataReady; 						// notifies the disk write thread that data is ready for writing
    std::condition_variable diskReady; 						// notifies the kernel manager thread that the disk writer thread is finished
    std::atomic<bool> isDiskReady { true }; 					// true if disk has finished being written to by disk write thread
    TestData globalTestData;		   					// pretend global data like FBuf, just for test
    void diskWriteFunc();
    void kernelManagerFunc();
};
///////////////////////////////////////////
#include "thread_manager.h"
int main(){
    ThreadManager manager;
    manager.create();
    for (int i = 0; i < 10; i++)  std::this_thread::sleep_for(std::chrono::seconds(2));
    manager.teardown();
    return EXIT_SUCCESS;
}
///////////////////////////////////////////
void ThreadManager::diskWriteFunc() {
    										// std::cout << "Disk write thread started" << std::endl;
    while (running){
        std::unique_lock<std::mutex> lock(condMutex);				// wait for data to become ready
        dataReady.wait(lock);							// dataReady is also notified if ThreadManager::teardown() is called,
        									// so we need to check if we're no longer
        									// running (since the data won't actually be ready in that case)
        if (!running) break;							// if we get here, we can process the data successfully
        									// std::cout << "Data received in disk write thread, string is: " 
        									// << globalTestData.justMakingSure << ", counter is: "
        									// << globalTestData.counter << std::endl;
        isDiskReady = false;							// pretend to write to disk, and inform the kernel manager we have finished
        std::this_thread::sleep_for(std::chrono::seconds(1));
        isDiskReady = true;
        diskReady.notify_all();							// std::cout << "Disk thread finished writing" << std::endl;
    }
}

void ThreadManager::kernelManagerFunc() {
    										// std::cout << "Kernel manager thread started" << std::endl;
    while (running){
        auto begin = std::chrono::steady_clock::now();
        std::this_thread::sleep_for(std::chrono::seconds(1));			// pretend to compute for a while
        globalTestData.counter++;
        globalTestData.justMakingSure = "It worked!";
        std::unique_lock<std::mutex> lock(condMutex);				// before notifying the disk write thread that we're ready, 
        									// ensure the disk write thread has finished
        if (!isDiskReady){
            									// std::cout << "Disk thread not yet ready, waiting for it to finish" 
            									// << std::endl;
            diskReady.wait(lock);
            if (!running) break;
        }									// now that we've confirmed disk thread is ready to receive data, send the data its way
        									// std::cout << "Finished waiting for disk thread, sending it new data" << std::endl;
        dataReady.notify_all();
        auto end = std::chrono::steady_clock::now();				// std::chrono::duration<double> time = end - begin;
        									// std::cout << "Time taken: " << time.count() << " seconds" 
        									// << std::endl;
    }
}

void ThreadManager::create() {
    										// std::cout << "Creating threads" << std::endl;
    running = true;
    isDiskReady = true; 							// disk thread starts ready to receive data
    diskWriteThread = std::thread(&ThreadManager::diskWriteFunc, this);
    kernelManagerThread = std::thread(&ThreadManager::kernelManagerFunc, this);
}

void ThreadManager::await(){
    diskWriteThread.join();
    kernelManagerThread.join();
}

void ThreadManager::teardown() {
    										// std::cout << "Destroying threads and waiting for completion" << std::endl;
    running = false;
    										// notify both threads if they're blocked waiting on a condition variable
    dataReady.notify_all();
    diskReady.notify_all();
    										// wait for threads to finish to prevent errors (graceful shutdown)
    diskWriteThread.join();
    kernelManagerThread.join();
}

